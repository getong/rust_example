* denort

** compilation

*** first cargo build

#+begin_src shell
cargo build
#+end_src

*** error log

#+begin_example
 Compiling temporal_rs v0.0.11
error: unexpected end of macro invocation902/970: temporal_rs
  --> /Users/gerald/.cargo/registry/src/rsproxy.cn-e3de039b2554c837/temporal_rs-0.0.11/src/tzdb.rs:60:1
   |
60 | timezone_provider::iana_normalizer_singleton!();
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing tokens in macro arguments
   |
note: while trying to match meta-variable `$providername:ident`
  --> /Users/gerald/.cargo/registry/src/rsproxy.cn-e3de039b2554c837/timezone_provider-0.0.16/src/./data/iana_normalizer.rs.data:6:6
   |
 6 |     ($providername:ident) => {
   |      ^^^^^^^^^^^^^^^^^^^

error: could not compile `temporal_rs` (lib) due to 1 previous error
#+end_example

*** modify ../Cargo.lock

change the ../Cargo.lock from:
#+begin_example
name = "temporal_rs"
version = "0.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7807e330b12e288b847a3e2a2b0dcd41ca764d0f90f9e8940f02c6ddd68cd2d7"
dependencies = [
 "combine",
 "core_maths",
 "icu_calendar",
 "icu_locale",
 "ixdtf",
 "jiff-tzdb",
 "num-traits",
 "timezone_provider 0.0.16",
 "tinystr",
 "tzif",
 "writeable",
]
#+end_example

to be

#+begin_example
name = "temporal_rs"
version = "0.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7807e330b12e288b847a3e2a2b0dcd41ca764d0f90f9e8940f02c6ddd68cd2d7"
dependencies = [
 "combine",
 "core_maths",
 "icu_calendar",
 "icu_locale",
 "ixdtf",
 "jiff-tzdb",
 "num-traits",
 "timezone_provider 0.0.14",
 "tinystr",
 "tzif",
 "writeable",
]
#+end_example

*** then second cargo build

#+begin_src shell
cargo build
#+end_src

** the serde version


#+begin_example
serde = { version = "=1.0.221", features = ["derive"] }
#+end_example

see [[https://github.com/DioxusLabs/dioxus/issues/4661][Cannot "cargo install dioxus-cli"" #4661]]


** libsui embeded rust code here in denort

** denort node package download

In run.rs, it download npm package.
#+begin_src rust
// use a dummy npm registry url
let npm_registry_url = Url::parse("https://localhost/").unwrap();
let root_dir_url = Arc::new(Url::from_directory_path(&root_path).unwrap());
let main_module = root_dir_url.join(&metadata.entrypoint_key).unwrap();
let npm_global_cache_dir = root_path.join(".deno_compile_node_modules");
let pkg_json_resolver = Arc::new(PackageJsonResolver::new(
    sys.clone(),
    Some(Arc::new(PackageJsonThreadLocalCache)),
));
let npm_registry_permission_checker = {
    let mode = match &metadata.node_modules {
        Some(NodeModules::Managed {
            node_modules_dir: Some(path),
        }) => NpmRegistryReadPermissionCheckerMode::Local(PathBuf::from(path)),
        Some(NodeModules::Byonm { .. }) => NpmRegistryReadPermissionCheckerMode::Byonm,
        Some(NodeModules::Managed {
            node_modules_dir: None,
        })
            | None => NpmRegistryReadPermissionCheckerMode::Global(npm_global_cache_dir.clone()),
    };
    NpmRegistryReadPermissionChecker::new(sys.clone(), mode)
};
let node_resolution_sys = NodeResolutionSys::new(sys.clone(), None);
let (in_npm_pkg_checker, npm_resolver) = match metadata.node_modules {
    Some(NodeModules::Managed { node_modules_dir }) => {
        // create an npmrc that uses the fake npm_registry_url to resolve packages
        let npmrc = Arc::new(ResolvedNpmRc {
            default_config: deno_npm::npm_rc::RegistryConfigWithUrl {
                registry_url: npm_registry_url.clone(),
                config: Default::default(),
            },
            scopes: Default::default(),
            registry_configs: Default::default(),
        });
        let npm_cache_dir = Arc::new(NpmCacheDir::new(
            &sys,
            npm_global_cache_dir,
            npmrc.get_all_known_registries_urls(),
        ));
        let snapshot = npm_snapshot.unwrap();
        let maybe_node_modules_path =
            node_modules_dir.map(|node_modules_dir| root_path.join(node_modules_dir));
        let in_npm_pkg_checker = DenoInNpmPackageChecker::new(CreateInNpmPkgCheckerOptions::Managed(
            ManagedInNpmPkgCheckerCreateOptions {
                root_cache_dir_url: npm_cache_dir.root_dir_url(),
                maybe_node_modules_path: maybe_node_modules_path.as_deref(),
            },
        ));
        let npm_resolution = Arc::new(NpmResolutionCell::new(NpmResolutionSnapshot::new(snapshot)));
        let npm_resolver = NpmResolver::<DenoRtSys>::new::<DenoRtSys>(
            NpmResolverCreateOptions::Managed(ManagedNpmResolverCreateOptions {
                npm_resolution,
                npm_cache_dir,
                sys: sys.clone(),
                maybe_node_modules_path,
                npm_system_info: Default::default(),
                npmrc,
            }),
        );
        (in_npm_pkg_checker, npm_resolver)
    }
    Some(NodeModules::Byonm {
        root_node_modules_dir,
    }) => {
        let root_node_modules_dir = root_node_modules_dir.map(|p| vfs.root().join(p));
        let in_npm_pkg_checker = DenoInNpmPackageChecker::new(CreateInNpmPkgCheckerOptions::Byonm);
        let npm_resolver = NpmResolver::<DenoRtSys>::new::<DenoRtSys>(
            NpmResolverCreateOptions::Byonm(ByonmNpmResolverCreateOptions {
                sys: node_resolution_sys.clone(),
                pkg_json_resolver: pkg_json_resolver.clone(),
                root_node_modules_dir,
            }),
        );
        (in_npm_pkg_checker, npm_resolver)
    }
#+end_src
