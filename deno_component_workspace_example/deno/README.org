* deno

copy from https://github.com/denoland/deno/tree/main/cli

** deno run

#+begin_src rust
DenoSubcommand::Run(run_flags)
#+end_src

** deno_lib loaded_module_source_to_module_source_code

#+begin_src rust
use deno_lib::loader::loaded_module_source_to_module_source_code;
#+end_src

** compile typescript into javascript

It uses _deno_resolver::emit::Emitter.maybe_emit_source_sync()_ to compile typescript file into javascript.

*** CliEmitter definition

#+begin_src rust
pub type CliEmitter = deno_resolver::emit::Emitter<DenoInNpmPackageChecker, CliSys>;
#+end_src


*** emitter in SharedCliModuleLoaderState

#+begin_src rust
struct SharedCliModuleLoaderState {
    emitter: Arc<CliEmitter>,
    // ... other part
}
#+end_src

** compile typescript into javascript

#+begin_src rust
let text = self
    .emitter
    .maybe_emit_source_sync(
        &specifier,
        media_type,
        // this is probably not super accurate due to require esm, but probably ok.
        // If we find this causes a lot of churn in the emit cache then we should
        // investigate how we can make this better
        ModuleKind::Cjs,
        &text.into(),
    )
    .map_err(JsErrorBox::from_err)?;
Ok(text.into())
#+end_src

** load typescript library

It uses _deno_resolver::loader::ModuleLoader::load()_ to load esm file

***  CliDenoResolverModuleLoader definition

#+begin_src rust
pub type CliDenoResolverModuleLoader = deno_resolver::loader::ModuleLoader<CliSys>;
#+end_src

*** SharedCliModuleLoaderState definition

#+begin_src rust
struct SharedCliModuleLoaderState {
    module_loader: Arc<CliDenoResolverModuleLoader>,
    //  ... other part
}
#+end_src

*** load() method

#+begin_src rust
match self
    .shared
    .module_loader
    .load(
        &graph,
        &specifier,
        maybe_referrer,
        &deno_resolver_requested_module_type,
    )
    .await?
{
    LoadedModuleOrAsset::Module(prepared_module) => {
        Ok(self.loaded_module_to_module_code_string_source(prepared_module, requested_module_type))
    }
    LoadedModuleOrAsset::ExternalAsset {
        specifier,
        statically_analyzable,
    } => {
        Ok(
            self
                .load_asset(
                    &specifier,
                    if statically_analyzable {
                        CheckSpecifierKind::Static
                    } else {
                        // force permissions
                        CheckSpecifierKind::Dynamic
                    },
                    requested_module_type,
                )
                .await?,
        )
    }
}
#+end_src


** download typescript dependency

graph_util.rs

*** usage
#+begin_src rust
self
    .build_graph_with_npm_resolution_and_build_options(
        graph,
        options.request,
        loader.as_mut_loader(),
        deno_graph::BuildOptions {
            skip_dynamic_deps: self.cli_options.unstable_lazy_dynamic_imports()
                && graph.graph_kind() == GraphKind::CodeOnly,
            is_dynamic: options.is_dynamic,
            passthrough_jsr_specifiers: false,
            executor: Default::default(),
            file_system: &self.sys,
            jsr_metadata_store: None,
            jsr_url_provider: &CliJsrUrlProvider,
            jsr_version_resolver: Cow::Borrowed(self.jsr_version_resolver.as_ref()),
            npm_resolver: Some(self.npm_graph_resolver.as_ref()),
            module_analyzer: &analyzer,
            module_info_cacher: self.module_info_cache.as_ref(),
            reporter: maybe_reporter,
            resolver: Some(&graph_resolver),
            locker: locker.as_mut().map(|l| l as _),
            unstable_bytes_imports: self.cli_options.unstable_raw_imports(),
            unstable_text_imports: self.cli_options.unstable_raw_imports(),
        },
        options.npm_caching,
    )
    .await?;

if let Some(npm_installer) = &self.npm_installer
    && graph.has_node_specifier
    && graph.graph_kind().include_types()
{
    npm_installer.inject_synthetic_types_node_package().await?;
}

pub async fn inject_synthetic_types_node_package(
    &self,
) -> Result<(), JsErrorBox> {
    self.npm_resolution_initializer.ensure_initialized().await?;

    // don't inject this if it's already been added
    if self
        .npm_resolution
        .any_top_level_package(|id| id.nv.name == "@types/node")
    {
        return Ok(());
    }

    let reqs = &[PackageReq::from_str("@types/node").unwrap()];
    self
        .add_package_reqs(reqs, PackageCaching::Only(reqs.into()))
        .await?;

    Ok(())
}
#+end_src

*** build_graph_with_npm_resolution_and_build_options

#+begin_src rust
async fn build_graph_with_npm_resolution_and_build_options<'a>(
    &self,
    graph: &mut ModuleGraph,
    request: BuildGraphRequest,
    loader: &'a mut dyn deno_graph::source::Loader,
    options: deno_graph::BuildOptions<'a>,
    npm_caching: NpmCachingStrategy,
) -> Result<(), BuildGraphWithNpmResolutionError> {
    // ensure an "npm install" is done if the user has explicitly
    // opted into using a node_modules directory
    if self
        .cli_options
        .specified_node_modules_dir()?
        .map(|m| m == NodeModulesDirMode::Auto)
        .unwrap_or(false)
        && let Some(npm_installer) = &self.npm_installer
    {
        let already_done = npm_installer
            .ensure_top_level_package_json_install()
            .await?;
        if !already_done && matches!(npm_caching, NpmCachingStrategy::Eager) {
            npm_installer.cache_packages(PackageCaching::All).await?;
        }
    }

    // fill the graph with the information from the lockfile
    let is_first_execution = graph.roots.is_empty();
    if is_first_execution {
        // populate the information from the lockfile
        if let Some(lockfile) = &self.lockfile {
            lockfile.fill_graph(graph)
        }
    }

    let initial_redirects_len = graph.redirects.len();
    let initial_package_deps_len = graph.packages.package_deps_sum();
    let initial_package_mappings_len = graph.packages.mappings().len();

    match request {
        BuildGraphRequest::Roots(roots) => {
            if roots.iter().any(|r| r.scheme() == "npm") && self.npm_resolver.is_byonm() {
                return Err(
                    BuildGraphWithNpmResolutionError::UnsupportedNpmSpecifierEntrypointResolutionWay,
                );
            }
            let imports = if graph.graph_kind().include_types() {
                // Resolve all the imports from every config file. We'll separate
                // them later based on the folder we're type checking.
                let mut imports_by_referrer =
                    IndexMap::<_, Vec<_>>::with_capacity(self.compiler_options_resolver.size());
                for (_, compiler_options_data, maybe_files) in self.compiler_options_resolver.entries() {
                    if let Some((referrer, files)) = maybe_files {
                        imports_by_referrer
                            .entry(referrer.as_ref())
                            .or_default()
                            .extend(files.iter().map(|f| f.relative_specifier.clone()));
                    }
                    for (referrer, types) in compiler_options_data.compiler_options_types().as_ref() {
                        imports_by_referrer
                            .entry(referrer)
                            .or_default()
                            .extend(types.iter().cloned());
                    }
                }
                imports_by_referrer
                    .into_iter()
                    .map(|(referrer, imports)| deno_graph::ReferrerImports {
                        referrer: referrer.clone(),
                        imports,
                    })
                    .collect()
            } else {
                Vec::new()
            };
            graph.build(roots, imports, loader, options).await;
        }
        BuildGraphRequest::Reload(urls) => graph.reload(urls, loader, options).await,
    }

    let has_redirects_changed = graph.redirects.len() != initial_redirects_len;
    let has_jsr_package_deps_changed =
        graph.packages.package_deps_sum() != initial_package_deps_len;
    let has_jsr_package_mappings_changed =
        graph.packages.mappings().len() != initial_package_mappings_len;

    if (has_redirects_changed || has_jsr_package_deps_changed || has_jsr_package_mappings_changed)
        && let Some(lockfile) = &self.lockfile
    {
        let mut lockfile = lockfile.lock();
        // https redirects
        if has_redirects_changed {
            let graph_redirects = graph
                .redirects
                .iter()
                .filter(|(from, _)| !matches!(from.scheme(), "npm" | "file" | "deno"));
            for (from, to) in graph_redirects {
                lockfile.insert_redirect(from.to_string(), to.to_string());
            }
        }
        // jsr package mappings
        if has_jsr_package_mappings_changed {
            for (from, to) in graph.packages.mappings() {
                lockfile.insert_package_specifier(
                    JsrDepPackageReq::jsr(from.clone()),
                    to.version.to_custom_string::<SmallStackString>(),
                );
            }
        }
        // jsr packages
        if has_jsr_package_deps_changed {
            for (nv, deps) in graph.packages.packages_with_deps() {
                lockfile.add_package_deps(nv, deps.cloned());
            }
        }
    }

    Ok(())
}
#+end_src

*** add_package_reqs

#+begin_src rust
pub async fn add_package_reqs(
    &self,
    packages: &[PackageReq],
    caching: PackageCaching<'_>,
) -> Result<(), JsErrorBox> {
    self.npm_resolution_initializer.ensure_initialized().await?;
    self
        .add_package_reqs_raw(packages, Some(caching))
        .await
        .dependencies_result
}
#+end_src