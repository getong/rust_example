#![allow(clippy::uninlined_format_args)]

use std::{
  fmt::Display,
  io::Cursor,
  net::{IpAddr, Ipv4Addr},
  path::Path,
  sync::Arc,
};

use futures::{future, Future, StreamExt};
use openraft::Config;
use poem::{listener::TcpListener, Route};
use poem_openapi::OpenApiService;
use tarpc::{
  server::{self, incoming::Incoming, Channel},
  tokio_serde::formats::Json,
};

use crate::{
  api_rpc::World,
  common::Api,
  network::Network,
  store::{new_storage, Request, Response},
};

pub mod api_rpc;
pub mod client;
pub mod common;
pub mod network;
pub mod store;
pub mod typ;
pub mod web_openapi;

pub type NodeId = u64;

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq, Eq, Default)]
pub struct Node {
  pub rpc_addr: String,
  pub api_addr: String,
}

impl Display for Node {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    write!(
      f,
      "Node {{ rpc_addr: {}, api_addr: {} }}",
      self.rpc_addr, self.api_addr
    )
  }
}

pub type SnapshotData = Cursor<Vec<u8>>;

openraft::declare_raft_types!(
    pub TypeConfig:
        D = Request,
        R = Response,
        Node = Node,
);

pub type ExampleRaft = openraft::Raft<TypeConfig>;

pub async fn start_example_raft_node<P>(
  node_id: NodeId,
  dir: P,
  http_addr: String,
  rpc_addr: String,
) -> std::io::Result<()>
where
  P: AsRef<Path>,
{
  // Create a configuration for the raft instance.
  let config = Config {
    heartbeat_interval: 250,
    election_timeout_min: 299,
    ..Default::default()
  };

  let config = Arc::new(config.validate().unwrap());

  let (log_store, state_machine_store) = new_storage(&dir).await;

  let kvs = state_machine_store.data.kvs.clone();

  // Create the network layer that will connect and communicate the raft instances and
  // will be used in conjunction with the store created above.
  let network = Network {};

  // Create a local raft instance.
  let raft = openraft::Raft::new(
    node_id,
    config.clone(),
    network,
    log_store,
    state_machine_store,
  )
  .await
  .unwrap();

  let api = Api {
    id: node_id,
    api_addr: http_addr.clone(),
    rpc_addr: rpc_addr.clone(),
    raft,
    key_values: kvs,
    config,
  };
  _ = start_tarpc(api.clone()).await;
  _ = start_poem(api).await;
  Ok(())
}

async fn start_tarpc(api: Api) -> Result<(), std::io::Error> {
  let server_addr = (IpAddr::V4(Ipv4Addr::LOCALHOST), 12345);
  let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default).await?;
  listener.config_mut().max_frame_length(usize::MAX);

  tokio::spawn(async move {
    listener
      // Ignore accept errors.
      .filter_map(|r| future::ready(r.ok()))
      .map(server::BaseChannel::with_defaults)
      // Limit channels to 1 per IP.
      .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
      // serve is generated by the service attribute. It takes as input any type implementing
      // the generated World trait.
      .map(|channel| {
        // let server = Api {
        //   num: num_clone.clone(),
        // };
        let api_clone = api.clone();
        channel.execute(api_clone.serve()).for_each(spawn)
      })
      // Max 10 channels.
      .buffer_unordered(10)
      .for_each(|_| async {})
      .await;
  });
  Ok(())
}

async fn spawn(fut: impl Future<Output = ()> + Send + 'static) {
  tokio::spawn(fut);
}

async fn start_poem(api: Api) -> Result<(), std::io::Error> {
  let api_service =
    OpenApiService::new(api, "Hello World", "1.0").server("http://localhost:3000/api");

  let app = Route::new().nest("/api", api_service);

  println!("access http://127.0.0.1:3000/api/hello");

  poem::Server::new(TcpListener::bind("127.0.0.1:3000"))
    .run(app)
    .await
}
